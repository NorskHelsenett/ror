import { Component, Input, OnInit } from '@angular/core';
import { ResourcesService } from '../../../core/services/resources.service';
import {
  Resource,
  ResourceClusterVulnerabilityReport,
  ResourceQuery,
  ResourceSet,
  VulnerabilityDismissalReason,
  VulnerabilityStatus,
} from '@rork8s/ror-resources/models';
import { TableModule } from 'primeng/table';
import { catchError, map, mergeMap, Observable, of, tap } from 'rxjs';
import { AsyncPipe, DatePipe, LowerCasePipe } from '@angular/common';
import { ButtonModule } from 'primeng/button';
import { FormsModule } from '@angular/forms';
import { DropdownModule } from 'primeng/dropdown';
import { BadgeModule } from 'primeng/badge';
import { InputTextModule } from 'primeng/inputtext';
import { ChartModule } from 'primeng/chart';
import { ChartData } from 'chart.js';
import { TabViewModule } from 'primeng/tabview';
import { CalendarModule } from 'primeng/calendar';
import { TranslateModule, TranslateService } from '@ngx-translate/core';
import { MultiSelectModule } from 'primeng/multiselect';
import { FilterMetadata, FilterMatchMode, SortMeta } from 'primeng/api';
import { ErrorComponent } from '../../../shared/components/error/error.component';

@Component({
  selector: 'app-cluster-vulnerability',
  standalone: true,
  imports: [
    TableModule,
    AsyncPipe,
    ButtonModule,
    FormsModule,
    DropdownModule,
    BadgeModule,
    DatePipe,
    InputTextModule,
    ChartModule,
    TabViewModule,
    CalendarModule,
    TranslateModule,
    MultiSelectModule,
    LowerCasePipe,
    ErrorComponent,
  ],
  templateUrl: './cluster-vulnerability.component.html',
  styleUrl: './cluster-vulnerability.component.scss',
})
export class ClusterVulnerabilityComponent implements OnInit {
  @Input({ required: true }) cluster!: any;

  clusterVulnerabilityReport$: Observable<ResourceClusterVulnerabilityReport>;
  clusterVulnerabilityReport: ResourceClusterVulnerabilityReport;
  resource: Resource;
  error: any;

  vulnerabilities: any[] = [];
  selectedVulnerabilities: any[] = [];

  chartData: ChartData = {
    labels: [],
    datasets: [],
  };

  loading: boolean;

  activeIndex: number;

  statuses: { label: string; value: VulnerabilityStatus }[] = Object.values(VulnerabilityStatus)
    .filter((s) => typeof s !== 'string')
    .map((s) => {
      return {
        label: this.getVulnerabilityStatusLabel(s),
        value: s,
      };
    });
  selectedStatus: VulnerabilityStatus;

  dismissalReasons: { label: string; value: VulnerabilityDismissalReason }[] = Object.values(VulnerabilityDismissalReason)
    .filter((r) => typeof r !== 'string')
    .map((r) => {
      return {
        label: this.getDismissalReasonLabel(r),
        value: r,
      };
    });
  selectedDismissalReason: VulnerabilityDismissalReason;

  comment: string;
  riskAssesment: string;

  severities: { label: string; value: string }[] = [
    {
      label: 'common.critical',
      value: 'CRITICAL',
    },
    {
      label: 'common.high',
      value: 'HIGH',
    },
    {
      label: 'common.medium',
      value: 'MEDIUM',
    },
    {
      label: 'common.low',
      value: 'LOW',
    },
    {
      label: 'common.unknown',
      value: 'UNKNOWN',
    },
  ];

  columns: { label: string; field: string }[] = [
    {
      label: 'id',
      field: 'id',
    },
    {
      label: 'severity',
      field: 'severity',
    },
    {
      label: 'score',
      field: 'score',
    },
    {
      label: 'title',
      field: 'title',
    },
    {
      label: 'firstObserved',
      field: 'firstObserved',
    },
    {
      label: 'lastObserved',
      field: 'lastObserved',
    },
    {
      label: 'status',
      field: 'status.status',
    },
  ];
  selectedColumns: { label: string; field: string }[] = [
    {
      label: 'id',
      field: 'id',
    },
    {
      label: 'severity',
      field: 'severity',
    },
    {
      label: 'score',
      field: 'score',
    },
    {
      label: 'title',
      field: 'title',
    },
    {
      label: 'status',
      field: 'status.status',
    },
  ];

  defaultSort: SortMeta[] = [
    {
      field: 'status.status',
      order: 1,
    },
    {
      field: 'score',
      order: -1,
    },
  ];

  readonly filters: { [s: string]: FilterMetadata | FilterMetadata[] } = {
    'status.status': {
      value: Object.values(VulnerabilityStatus).filter((s) => typeof s !== 'string' && s !== VulnerabilityStatus.DISMISSED),
      matchMode: FilterMatchMode.IN,
    },
  };

  constructor(
    private resourceService: ResourcesService,
    private translateService: TranslateService,
  ) {}

  ngOnInit(): void {
    this.clusterVulnerabilityReport$ = this.getClusterVulnerabilityReport();
  }

  getClusterVulnerabilityReport(): Observable<ResourceClusterVulnerabilityReport> {
    this.loading = true;
    const query: ResourceQuery = {
      versionkind: {
        Kind: 'ClusterVulnerabilityReport',
        Group: '',
        Version: 'general.ror.internal/v1alpha1',
      },
      ownerrefs: [
        {
          scope: 'cluster',
          subject: this.cluster?.clusterId,
        },
      ],
    };
    return this.resourceService.getResources(query).pipe(
      map((resourceSet) => {
        this.resource = resourceSet?.resources?.find((r) => r != null);
        return resourceSet?.resources?.map((resource) => resource?.clustervulnerabilityreport)?.find((report) => report != null);
      }),
      tap((report) => {
        this.clusterVulnerabilityReport = report;
        this.vulnerabilities = this.getVulnerabilities(report);
        this.chartData = this.getChartData(report);
        this.error = null;
        this.loading = false;
      }),
      catchError((error) => {
        this.loading = false;
        this.error = error;
        return of(error);
      }),
    );
  }

  updateClusterVulnerabilityReport(): void {
    this.loading = true;
    const currentDate: Date = new Date();
    const until: Date = new Date(new Date(currentDate).setMonth(currentDate.getMonth() + 6));
    this.selectedVulnerabilities.forEach((v) => {
      this.clusterVulnerabilityReport.report[v.id].status.status = this.selectedStatus;
      if (this.clusterVulnerabilityReport.report[v.id].status.status === VulnerabilityStatus.DISMISSED) {
        this.clusterVulnerabilityReport.report[v.id].status.until = until.toISOString();
        this.clusterVulnerabilityReport.report[v.id].status.reason = this.selectedDismissalReason;
        this.clusterVulnerabilityReport.report[v.id].status.riskAssessment = this.riskAssesment;
      }
      this.clusterVulnerabilityReport.report[v.id].status.comment = this.comment;
    });
    this.resource.clustervulnerabilityreport = this.clusterVulnerabilityReport;
    let rs: ResourceSet = {
      resources: [this.resource],
    };
    this.clusterVulnerabilityReport$ = this.resourceService.createResource(rs).pipe(
      mergeMap(() => {
        this.resetSelections();
        this.error = null;
        this.loading = false;
        return this.getClusterVulnerabilityReport();
      }),
      catchError((error) => {
        this.error = error;
        this.loading = false;
        return of(error);
      }),
    );
  }

  getVulnerabilities(clusterReport: ResourceClusterVulnerabilityReport): any[] {
    if (!clusterReport?.report) {
      return [];
    }
    return Object.entries(clusterReport?.report)?.map((entry) => {
      return { id: entry[0], ...entry[1] };
    });
  }

  getBadgeColor(severity: string | VulnerabilityStatus): 'secondary' | 'success' | 'info' | 'warning' | 'danger' {
    switch (severity) {
      case 'CRITICAL':
        return 'danger';
      case 'HIGH':
        return 'warning';
      case 'MEDIUM':
        return 'info';
      case 'LOW':
        return 'success';
      case VulnerabilityStatus.NOT_ASSESSED:
        return 'danger';
      case VulnerabilityStatus.CONFIRMED:
        return 'info';
      case VulnerabilityStatus.NEEDS_TRIAGE:
        return 'secondary';
      case VulnerabilityStatus.DISMISSED:
        return 'warning';
      default:
        return 'secondary';
    }
  }

  getChartData(clusterVulnerabilityReport: ResourceClusterVulnerabilityReport): ChartData {
    if (clusterVulnerabilityReport) {
      return {
        labels: Object.keys(clusterVulnerabilityReport?.summary)?.map((l) => {
          return this.translateService.instant('common.' + l);
        }),
        datasets: [
          {
            label: this.translateService.instant('pages.clustervulnerabilityreport.vulnerabilities'),
            data: Object.values(clusterVulnerabilityReport?.summary),
            backgroundColor: [
              'rgba(255, 0, 0, 0.5)',
              'rgba(255, 165, 0, 0.5)',
              'rgba(255, 255, 0, 0.5)',
              'rgba(0, 255, 0, 0.5)',
              'rgba(0, 0, 255, 0.5)',
            ],
            borderColor: ['rgb(255, 0, 0)', 'rgb(255, 165, 0)', 'rgb(255, 255, 0)', 'rgb(0, 255, 0)', 'rgb(0, 0, 255)'],
            borderWidth: 1,
          },
        ],
      };
    }
    return {
      labels: [],
      datasets: [],
    };
  }

  getField(object: any, field: string): any {
    let nestedField: string[] = field?.split('.');
    let value: any = object[nestedField?.shift()];
    nestedField.forEach((field) => {
      value = value[field];
    });
    return value;
  }

  resetSelections(): void {
    this.selectedDismissalReason = undefined;
    this.riskAssesment = '';
    this.selectedStatus = undefined;
    this.selectedVulnerabilities = [];
    this.comment = '';
  }

  getVulnerabilityStatusLabel(status: VulnerabilityStatus): string {
    let l: string = 'pages.clustervulnerabilityreport.';
    switch (status) {
      case VulnerabilityStatus.NOT_ASSESSED:
        l += 'notAssessed';
        break;
      case VulnerabilityStatus.NEEDS_TRIAGE:
        l += 'needsTriage';
        break;
      case VulnerabilityStatus.CONFIRMED:
        l += 'confirmed';
        break;
      case VulnerabilityStatus.DISMISSED:
        l += 'dismissed';
        break;
      default:
        return 'common.unknown';
    }
    return l;
  }

  getDismissalReasonLabel(reason: VulnerabilityDismissalReason): string {
    let l: string = 'pages.clustervulnerabilityreport.';
    switch (reason) {
      case VulnerabilityDismissalReason.ACCEPTABLE_RISK:
        l += 'acceptableRisk';
        break;
      case VulnerabilityDismissalReason.FALSE_POSITIVE:
        l += 'falsePositive';
        break;
      case VulnerabilityDismissalReason.NOT_APPLICABLE:
        l += 'notApplicable';
        break;
      default:
        return 'common.unknown';
    }
    return l;
  }
}
