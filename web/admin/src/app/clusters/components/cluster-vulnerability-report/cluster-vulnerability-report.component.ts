import { ChangeDetectorRef, Component, OnDestroy, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { Observable, Subscription, catchError, of, tap } from 'rxjs';
import { VulnerabilityReportsView } from '../../../core/models/vulnerabilityReport';
import { ClustersService } from '../../../core/services/clusters.service';
import { ExportService } from '../../../core/services/export.service';

@Component({
  selector: 'app-cluster-vulnerability-report',
  templateUrl: './cluster-vulnerability-report.component.html',
  styleUrls: ['./cluster-vulnerability-report.component.scss'],
})
export class ClusterVulnerabilityReportComponent implements OnInit, OnDestroy {
  reports$: Observable<VulnerabilityReportsView>;
  reportsError: any;
  clusterID: string;
  showExportChoices: boolean;

  private subscriptions: Subscription = new Subscription();

  constructor(
    private clustersService: ClustersService,
    private changeDetector: ChangeDetectorRef,
    private route: ActivatedRoute,
    private exportService: ExportService,
  ) {}

  ngOnInit(): void {
    this.subscriptions.add(
      this.route.params
        .pipe(
          tap((data: any) => {
            this.clusterID = data?.id;
            this.getVulnerabilityReports();
          }),
        )
        .subscribe(() => {
          this.changeDetector.detectChanges();
        }),
    );
  }

  ngOnDestroy(): void {
    this.subscriptions.unsubscribe();
  }

  getVulnerabilityReports(): void {
    this.reports$ = this.clustersService.getVulnerabilityReports(this.clusterID).pipe(
      catchError((err) => {
        this.reportsError = err;
        this.changeDetector.detectChanges();
        return of(err);
      }),
    );
  }

  exportToCsv(reports: VulnerabilityReportsView): void {
    this.exportService.exportToCsv(this.reportsToArray(reports), 'vulnerability-reports.csv');
  }

  exportToExcel(reports: VulnerabilityReportsView): void {
    this.exportService.exportAsExcelFile(this.reportsToArray(reports), 'vulnerability-reports');
  }

  reportsToArray(reports: VulnerabilityReportsView): any[] {
    const reportArray: any[] = [];
    reports?.namespaces?.forEach((namespace) => {
      namespace?.reports?.forEach((report) => {
        report?.vulnerabilities?.forEach((vulnerability: any) => {
          const entry: any = {};
          entry.cluster = reports?.clusterId;
          entry.namespace = namespace?.name;
          entry.apiVersion = report?.owner_ref?.apiVersion;
          entry.kind = report?.owner_ref?.kind;
          entry.name = report?.owner_ref?.name;
          entry.artifactRepository = report?.artifact?.repository;
          entry.artifactTag = report?.artifact?.tag;
          entry.title = vulnerability?.title;
          entry.severity = vulnerability?.severity;
          entry.score = vulnerability?.score;
          entry.id = vulnerability?.vulnerabilityID;
          entry.link = vulnerability?.primaryLink;
          entry.resource = vulnerability?.resource;
          entry.installedVersion = vulnerability?.installedVersion;
          entry.fixedVersion = vulnerability?.fixedVersion;
          reportArray?.push(entry);
        });
      });
    });
    return reportArray?.length > 0 ? reportArray : [''];
  }
}
