package batch

import (
	"context"
	"fmt"
	"os"
	"time"

	"github.com/NorskHelsenett/ror/cmd/vulnerability/cluster"

	"github.com/NorskHelsenett/ror/pkg/rlog"
	"github.com/NorskHelsenett/ror/pkg/rorresources/rortypes"
)

var (
	vulnerabilityBatcher batcher
	tickDuration         time.Duration
)

type batcher struct {
	cancel <-chan os.Signal
	input  chan rortypes.RorResourceOwnerReference
	ticker *time.Ticker
	owners map[rortypes.RorResourceOwnerReference]time.Time
}

func init() {
	tickDuration = 10 * time.Second
	vulnerabilityBatcher = batcher{
		cancel: make(<-chan os.Signal, 1),
		input:  make(chan rortypes.RorResourceOwnerReference),
		ticker: time.NewTicker(tickDuration),
		owners: map[rortypes.RorResourceOwnerReference]time.Time{},
	}
	go vulnerabilityBatcher.start()
}

func (b *batcher) start() {
	for {
		select {
		case <-b.ticker.C:
			for k, v := range b.owners {
				if time.Since(v) > 10*time.Second {
					b.flush(k)
				}
			}
		case o := <-b.input:
			// reset timestamp so new batches are sent in one go
			b.owners[o] = time.Now()
		case <-b.cancel:
			return
		}
	}
}

// flush will attempt to create VulnerabilityEvents from map of vulnerabilities
// if it fails to create a VulnerabilityEvents the map entry will not be deleted
// and will be retried on the next flush
func (b *batcher) flush(o rortypes.RorResourceOwnerReference) {
	ctx := context.Background()
	rlog.Debug(fmt.Sprintf("flushing vulnerabilities for owner %v", o))
	err := cluster.CreateClusterVulnerabilityReport(ctx, o)
	if err != nil {
		rlog.Error(fmt.Sprintf("error when creating cluster vulnerability report for owner %v", o), err)
		return
	}
	delete(b.owners, o)
}

// public function to add a vulnerability to the channel of the batcher
func AddOwner(o rortypes.RorResourceOwnerReference) {
	vulnerabilityBatcher.input <- o
}
