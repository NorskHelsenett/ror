package cluster

import (
	"context"
	"fmt"
	"time"

	"github.com/NorskHelsenett/ror/cmd/vulnerability/notification"
	"github.com/NorskHelsenett/ror/cmd/vulnerability/ror"
	"github.com/NorskHelsenett/ror/pkg/rlog"
	"github.com/NorskHelsenett/ror/pkg/rorresources"
	"github.com/NorskHelsenett/ror/pkg/rorresources/rortypes"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
	notificationTimeLimit          = 48 * time.Hour
	rorApiVersion                  = "general.ror.internal/v1alpha1"
	vulnerabilityReportApiVersion  = "aquasecurity.github.io/v1alpha1"
	vulnerabilityReportKind        = "VulnerabilityReport"
	vulnerabilityWhitelistKind     = "VulnerabilityWhitelist"
	clusterVulnerabilityReportKind = "ClusterVulnerabilityReport"
)

func CreateClusterVulnerabilityReport(ctx context.Context, owner rortypes.RorResourceOwnerReference) error {
	vrQuery := createVulnerabilityReportQuery(owner)
	vrs, err := ror.Client.ResourceV2().Get(ctx, *vrQuery)
	if err != nil {
		return err
	}

	// create unique uuid per owner
	cvrQuery := createClusterVulnerabilityReportQuery(owner)
	cvrRS, err := ror.Client.ResourceV2().Get(ctx, *cvrQuery)
	if err != nil {
		return err
	}

	// create new if not exists
	var cvr *rortypes.ResourceClusterVulnerabilityReport
	if cvrRS.Len() == 0 {
		cvr = newClusterVulnerabilityReport()
	} else {
		cvr = cvrRS.Get().ClusterVulnerabilityReport().Get()
	}

	// reset summary and owners before looping over vulnerabilities
	resetSummary(cvr)
	resetOwners(cvr)

	vs := []notification.Vulnerability{}
	// this needs to be refactored
	for _, vr := range vrs.GetAll() {
		for _, v := range vr.VulnerabilityReport().Get().Report.Vulnerabilities {
			// check if vulnerability is new and add to notification list
			r, ok := cvr.Report[v.VulnerabilityID]
			if ok {
				if time.Since(r.LastObserved) > notificationTimeLimit && (r.Status.Status != rortypes.DISMISSED || time.Now().After(r.Status.Until)) {
					vs = append(vs, notification.Vulnerability{
						Id:       v.VulnerabilityID,
						Severity: v.Severity,
						Title:    v.Title,
					})
				}
			} else {
				vs = append(vs, notification.Vulnerability{
					Id:       v.VulnerabilityID,
					Severity: v.Severity,
					Title:    v.Title,
				})
			}
			// update summary and last observed timestamp for vulnerability
			updateReport(cvr, v, vr.GetMetadata().OwnerReferences, vr.VulnerabilityReport().Get().Report.Artifact, vr.GetMetadata().Namespace)
		}
	}

	rs := createClusterVulnerabilityReportResourceSet(cvr, owner)
	_, err = ror.Client.ResourceV2().Update(ctx, *rs)
	if err != nil {
		return err
	}

	// only send VulnerabilityEvent if new vulnerabilites
	if len(vs) > 0 {
		rlog.Debug(fmt.Sprintf("%d new vulnerabilities found, creating VulnerabilityEvent", len(vs)))
		err = notification.CreateVulnerabilityEvent(ctx, vs, cvr.Summary, owner)
		if err != nil {
			return err
		}
	}
	return nil
}

func newClusterVulnerabilityReport() *rortypes.ResourceClusterVulnerabilityReport {
	cvr := rortypes.ResourceClusterVulnerabilityReport{}
	cvr.Summary = rortypes.ResourceClusterVulnerabilityReportSummary{}
	cvr.Report = map[string]rortypes.ResourceClusterVulnerabilityReportReport{}
	return &cvr
}

func resetSummary(cvr *rortypes.ResourceClusterVulnerabilityReport) {
	cvr.Summary = rortypes.ResourceClusterVulnerabilityReportSummary{}
}

func resetOwners(cvr *rortypes.ResourceClusterVulnerabilityReport) {
	for id := range cvr.Report {
		if vulnerability, ok := cvr.Report[id]; ok {
			vulnerability.Owners = nil
			cvr.Report[id] = vulnerability
		}
	}
}

// this needs to be refactored
func updateReport(cvr *rortypes.ResourceClusterVulnerabilityReport, v rortypes.ResourceVulnerabilityReportReportVulnerability, ownerReferences []v1.OwnerReference, artifact rortypes.ResourceVulnerabilityReportReportArtifact, namespace string) {
	ts := time.Now()
	if vulnerability, ok := cvr.Report[v.VulnerabilityID]; ok {
		if len(vulnerability.Owners) > 0 {
			vulnerability.Owners = append(vulnerability.Owners, rortypes.ResourceClusterVulnerabilityReportReportOwner{
				Digest:           artifact.Digest,
				Repository:       artifact.Repository,
				Tag:              artifact.Tag,
				Resource:         v.Resource,
				InstalledVersion: v.InstalledVersion,
				FixedVersion:     v.FixedVersion,
				OwnerReferences:  ownerReferences,
				Namespace:        namespace,
			})
		} else {
			vulnerability.Owners = []rortypes.ResourceClusterVulnerabilityReportReportOwner{
				{
					Digest:           artifact.Digest,
					Repository:       artifact.Repository,
					Tag:              artifact.Tag,
					Resource:         v.Resource,
					InstalledVersion: v.InstalledVersion,
					FixedVersion:     v.FixedVersion,
					OwnerReferences:  ownerReferences,
					Namespace:        namespace,
				},
			}
			switch v.Severity {
			case "CRITICAL":
				cvr.Summary.Critical++
			case "HIGH":
				cvr.Summary.High++
			case "MEDIUM":
				cvr.Summary.Medium++
			case "LOW":
				cvr.Summary.Low++
			default:
				cvr.Summary.Unknown++
			}
		}
		vulnerability.LastObserved = ts
		cvr.Report[v.VulnerabilityID] = vulnerability
	} else {
		cvr.Report[v.VulnerabilityID] = rortypes.ResourceClusterVulnerabilityReportReport{
			Severity:      v.Severity,
			Score:         v.Score,
			Title:         v.Title,
			Link:          v.Link,
			FirstObserved: ts,
			LastObserved:  ts,
			Owners: []rortypes.ResourceClusterVulnerabilityReportReportOwner{
				{
					Digest:           artifact.Digest,
					Repository:       artifact.Repository,
					Tag:              artifact.Tag,
					Resource:         v.Resource,
					InstalledVersion: v.InstalledVersion,
					FixedVersion:     v.FixedVersion,
					OwnerReferences:  ownerReferences,
					Namespace:        namespace,
				},
			},
		}
		switch v.Severity {
		case "CRITICAL":
			cvr.Summary.Critical++
		case "HIGH":
			cvr.Summary.High++
		case "MEDIUM":
			cvr.Summary.Medium++
		case "LOW":
			cvr.Summary.Low++
		default:
			cvr.Summary.Unknown++
		}
	}
}

func createVulnerabilityReportQuery(owner rortypes.RorResourceOwnerReference) *rorresources.ResourceQuery {
	query := rorresources.NewResourceQuery()
	query.VersionKind.Kind = vulnerabilityReportKind
	query.VersionKind.Version = vulnerabilityReportApiVersion
	query.OwnerRefs = make([]rortypes.RorResourceOwnerReference, 0)
	query.OwnerRefs = append(query.OwnerRefs, owner)
	query.Filters = make([]rorresources.ResourceQueryFilter, 0)
	query.Filters = append(query.Filters, rorresources.ResourceQueryFilter{Field: "rormeta.internal", Value: "false", Operator: rorresources.FilterOperatorEq, Type: rorresources.FilterTypeBool})
	return query
}

func createVulnerabilityWhitelistQuery(owner rortypes.RorResourceOwnerReference) *rorresources.ResourceQuery {
	query := rorresources.NewResourceQuery()
	query.VersionKind.Kind = vulnerabilityWhitelistKind
	query.VersionKind.Version = rorApiVersion
	query.OwnerRefs = make([]rortypes.RorResourceOwnerReference, 0)
	query.OwnerRefs = append(query.OwnerRefs, owner)
	return query
}

func createClusterVulnerabilityReportQuery(owner rortypes.RorResourceOwnerReference) *rorresources.ResourceQuery {
	cvrQuery := rorresources.NewResourceQuery()
	cvrQuery.VersionKind.Kind = clusterVulnerabilityReportKind
	cvrQuery.VersionKind.Version = rorApiVersion
	cvrQuery.OwnerRefs = make([]rortypes.RorResourceOwnerReference, 0)
	cvrQuery.OwnerRefs = append(cvrQuery.OwnerRefs, owner)
	return cvrQuery
}

func createClusterVulnerabilityReportResourceSet(cvr *rortypes.ResourceClusterVulnerabilityReport, owner rortypes.RorResourceOwnerReference) *rorresources.ResourceSet {
	r := rorresources.NewRorResource(clusterVulnerabilityReportKind, rorApiVersion)
	r.SetClusterVulnerabilityReport(cvr)
	r.RorMeta.Action = rortypes.K8sActionUpdate
	r.RorMeta.Ownerref = owner
	rs := rorresources.NewResourceSet()
	rs.Add(r)
	return rs
}
