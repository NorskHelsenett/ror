package cluster

import (
	"context"
	"fmt"
	"time"

	"github.com/NorskHelsenett/ror/cmd/vulnerability/notification"
	"github.com/NorskHelsenett/ror/cmd/vulnerability/ror"

	"github.com/NorskHelsenett/ror/pkg/rlog"
	"github.com/NorskHelsenett/ror/pkg/rorresources"
	"github.com/NorskHelsenett/ror/pkg/rorresources/rortypes"
	"github.com/google/uuid"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
)

const (
	apiVersion = "general.ror.internal/v1alpha1"
	kind       = "ClusterVulnerabilityReport"
)

func CreateClusterVulnerabilityReport(owner rortypes.RorResourceOwnerReference) error {
	vrQuery := createVulnerabilityReportQuery(owner)
	vrs, err := ror.Client.ResourceV2().Get(context.Background(), *vrQuery)
	if err != nil {
		return err
	}

	// create unique uuid per owner
	uid := uuid.NewSHA1(uuid.Nil, []byte(owner.String())).String()
	cvrQuery := createClusterVulnerabilityReportQuery(uid, owner)
	cvrRS, err := ror.Client.ResourceV2().Get(context.Background(), *cvrQuery)
	if err != nil {
		return err
	}

	// create new if not exists
	var cvr *rortypes.ResourceClusterVulnerabilityReport
	if cvrRS.Len() == 0 {
		cvr = newClusterVulnerabilityReport()
	} else {
		cvr = cvrRS.Get().ClusterVulnerabilityReport().Get()
	}

	// reset summary and owners before looping over vulnerabilities
	resetSummary(cvr)
	resetOwners(cvr)

	// slice containing all new vulnerabilities
	vs := []rortypes.ResourceVulnerabilityReportReportVulnerability{}
	for _, vr := range vrs.GetAll() {

		for _, v := range vr.VulnerabilityReport().Get().Report.Vulnerabilities {
			_, ok := cvr.Report.Vulnerabilities[v.VulnerabilityID]
			if ok {
				if time.Since(cvr.Report.Vulnerabilities[v.VulnerabilityID].LastObserved) > 30*time.Hour {
					vs = append(vs, v)
				}
			} else {
				vs = append(vs, v)
			}
			// update summary and last observed timestamp for vulnerability
			updateReport(cvr, v, vr.GetMetadata().OwnerReferences)
		}
	}

	rs := createClusterVulnerabilityReportResourceSet(cvr, owner, uid)
	_, err = ror.Client.ResourceV2().Update(context.Background(), *rs)
	if err != nil {
		return err
	}

	// only send VulnerabilityEvent if new vulnerabilites
	if len(vs) > 0 {
		rlog.Debug(fmt.Sprintf("%d new vulnerabilities found, creating VulnerabilityEvent", len(vs)))
		err = notification.CreateVulnerabilityEvent(vs, cvr.Report.Summary, owner)
		if err != nil {
			return err
		}
	}
	return nil
}

func newClusterVulnerabilityReport() *rortypes.ResourceClusterVulnerabilityReport {
	cvr := rortypes.ResourceClusterVulnerabilityReport{}
	cvr.Report.Summary = rortypes.ResourceClusterVulnerabilityReportSummary{}
	cvr.Report.Vulnerabilities = map[string]rortypes.ResourceClusterVulnerabilityReportStatus{}
	return &cvr
}

func resetSummary(cvr *rortypes.ResourceClusterVulnerabilityReport) {
	cvr.Report.Summary = rortypes.ResourceClusterVulnerabilityReportSummary{}
}

func resetOwners(cvr *rortypes.ResourceClusterVulnerabilityReport) {
	for id := range cvr.Report.Vulnerabilities {
		if vulnerability, ok := cvr.Report.Vulnerabilities[id]; ok {
			vulnerability.OwnerReferences = nil
			cvr.Report.Vulnerabilities[id] = vulnerability
		}
	}
}

func updateReport(cvr *rortypes.ResourceClusterVulnerabilityReport, v rortypes.ResourceVulnerabilityReportReportVulnerability, ownerReferences []v1.OwnerReference) {
	if vulnerability, ok := cvr.Report.Vulnerabilities[v.VulnerabilityID]; ok {
		if len(vulnerability.OwnerReferences) > 0 {
			vulnerability.OwnerReferences = append(vulnerability.OwnerReferences, ownerReferences...)
		} else {
			vulnerability.OwnerReferences = ownerReferences
			switch v.Severity {
			case "CRITICAL":
				cvr.Report.Summary.Critical++
			case "HIGH":
				cvr.Report.Summary.High++
			case "MEDIUM":
				cvr.Report.Summary.Medium++
			case "LOW":
				cvr.Report.Summary.Low++
			default:
				cvr.Report.Summary.Unknown++
			}
		}
		vulnerability.LastObserved = time.Now()
		cvr.Report.Vulnerabilities[v.VulnerabilityID] = vulnerability
	} else {
		cvr.Report.Vulnerabilities[v.VulnerabilityID] = rortypes.ResourceClusterVulnerabilityReportStatus{
			ResourceVulnerabilityReportReportVulnerability: v,
			LastObserved:    time.Now(),
			OwnerReferences: ownerReferences,
		}
		switch v.Severity {
		case "CRITICAL":
			cvr.Report.Summary.Critical++
		case "HIGH":
			cvr.Report.Summary.High++
		case "MEDIUM":
			cvr.Report.Summary.Medium++
		case "LOW":
			cvr.Report.Summary.Low++
		default:
			cvr.Report.Summary.Unknown++
		}
	}
}

func createVulnerabilityReportQuery(owner rortypes.RorResourceOwnerReference) *rorresources.ResourceQuery {
	query := rorresources.NewResourceQuery()
	query.VersionKind.Kind = "VulnerabilityReport"
	query.VersionKind.Version = "aquasecurity.github.io/v1alpha1"
	query.OwnerRefs = make([]rortypes.RorResourceOwnerReference, 0)
	query.OwnerRefs = append(query.OwnerRefs, owner)
	query.Filters = make([]rorresources.ResourceQueryFilter, 0)
	query.Filters = append(query.Filters, rorresources.ResourceQueryFilter{Field: "rormeta.internal", Value: "false", Operator: rorresources.FilterOperatorEq, Type: rorresources.FilterTypeBool})
	return query
}

func createClusterVulnerabilityReportQuery(uid string, owner rortypes.RorResourceOwnerReference) *rorresources.ResourceQuery {
	cvrQuery := rorresources.NewResourceQuery()
	cvrQuery.WithUID(uid)
	cvrQuery.VersionKind.Kind = kind
	cvrQuery.VersionKind.Version = apiVersion
	cvrQuery.OwnerRefs = make([]rortypes.RorResourceOwnerReference, 0)
	cvrQuery.OwnerRefs = append(cvrQuery.OwnerRefs, owner)
	return cvrQuery
}

func createClusterVulnerabilityReportResourceSet(cvr *rortypes.ResourceClusterVulnerabilityReport, owner rortypes.RorResourceOwnerReference, uid string) *rorresources.ResourceSet {
	r := rorresources.NewRorResource(kind, apiVersion)
	r.SetClusterVulnerabilityReport(cvr)
	r.Metadata.UID = types.UID(uid)
	r.RorMeta.Action = rortypes.K8sActionUpdate
	r.RorMeta.Ownerref = owner
	rs := rorresources.NewResourceSet()
	rs.Add(r)
	return rs
}
