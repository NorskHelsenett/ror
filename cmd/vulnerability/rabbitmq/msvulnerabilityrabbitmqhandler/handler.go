package msvulnerabilityrabbitmqhandler

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/NorskHelsenett/ror/cmd/vulnerability/batch"
	"github.com/NorskHelsenett/ror/cmd/vulnerability/vulnerabilityconnections"

	"github.com/NorskHelsenett/ror/pkg/apicontracts/apiresourcecontracts"
	"github.com/NorskHelsenett/ror/pkg/handlers/rabbitmqhandler"
	aclmodels "github.com/NorskHelsenett/ror/pkg/models/aclmodels"
	"github.com/NorskHelsenett/ror/pkg/rlog"
	"github.com/NorskHelsenett/ror/pkg/rorresources/rortypes"
	amqp "github.com/rabbitmq/amqp091-go"
)

func StartListening() {
	go func() {
		config := rabbitmqhandler.RabbitMQListnerConfig{
			Client:    vulnerabilityconnections.RabbitMQConnection,
			QueueName: "ms-vulnerability",
			Consumer:  "",
			AutoAck:   false,
			Exclusive: false,
			NoLocal:   false,
			NoWait:    false,
			Args: amqp.Table{
				"kind": "VulnerabilityReport",
			},
		}
		rh := rabbitmqhandler.New(config, vulnerabilityhandler{})
		err := vulnerabilityconnections.RabbitMQConnection.RegisterHandler(rh)
		if err != nil {
			panic(err)
		}
	}()
}

type vulnerabilityhandler struct{}

func (h vulnerabilityhandler) HandleMessage(ctx context.Context, message amqp.Delivery) error {
	var resource apiresourcecontracts.ResourceUpdateModel
	err := json.Unmarshal(message.Body, &resource)
	if err != nil {
		return fmt.Errorf("unable to unmarshal amqp body to resource update model: %w", err)
	}

	if resource.Version != apiresourcecontracts.ResourceVersionV2 {
		errMsg := "resourcev1 is not supported"
		rlog.Warnc(ctx, errMsg)
		return errors.New(errMsg)
	}

	// do we need this if? should be handled by rabbit queue args
	if resource.Kind == "VulnerabilityReport" {
		batch.AddOwner(rortypes.RorResourceOwnerReference{Subject: aclmodels.Acl2Subject(resource.Owner.Subject), Scope: resource.Owner.Scope})
	}

	return nil
}
