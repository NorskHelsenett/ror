{"config":{"lang":["no"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":""},{"location":"#release-operate-report","title":"Release Operate Report","text":"<pre><code>\"ror\" is the Norwegian word for rudder.\nA rudder is a control device where a blade or a fin is attached to a shaft.\nThis is used to change the direction of a force in a fluid or gas.\nRudders are most commonly used on boats, ships, and aircraft.\n</code></pre> <p>ROR is a multi cluster management tool aimed to streamline the process of creating kubernetes clusters on any provider or architecture. ROR is developed by Norsk Helsenett SF but we move to remove any references and internal logic related to the organization. Our aim is to release the project as an open source project.</p>"},{"location":"#api-driven","title":"API driven","text":"<p>ROR is API driven with provided web and cli clients. ROR leverages the Kubernetes API definition extending it with additional metadata and resources.</p>"},{"location":"#provider-agnostic-but-extensible","title":"Provider agnostic but extensible","text":"<p>ROR is aimed to be provider/cloud agnostic but stil extensible to provide provider specific functionality by the use of microservices.</p>"},{"location":"#distributed-model","title":"Distributed model","text":"<p>ROR relies on a distributed model using agents in each cluster. This model ensures that ROR can't be used to access the cluster directly.</p>"},{"location":"#development-values","title":"Development values","text":"<ul> <li>Support simple primitives first then extend support if needed.</li> <li>Collect only needed data, scope the datamodel to suit our need.</li> </ul>"},{"location":"#features","title":"Features","text":""},{"location":"#release","title":"Release","text":"function milestone done description create cluster 1.0 90% Create cluster from sclusterspec, allows integration with other teams managementssolution. upgrade/scale cluster 1.0 20% Upgrade/scal cluster from changing sclusterspec, allows integration with other teams managementssolution. decomission cluster 1.0 20% Decomission cluster, allows integration with other teams managementssolution."},{"location":"#operate","title":"Operate","text":"function milestone done description cluster inventory 1.0 Collect basic clustrerinformation cluster status 1.0 Calculate healthscore for the cluster based on established rules. Configuration management 1.0 - Dex integrations 1.0 Automatic provisioning of dex clientid and clientsecrets - tooling-config 1.0 90% Full config of tooling from ROR - Authorization 1.0 Configure access to clusters from ROR"},{"location":"#report","title":"Report","text":"function milestone done description - Metrics 1.0 Gather basic cluster metrics - Security scan 1.0 Run scans of cluster components like config, images certificates..."},{"location":"components/","title":"Components","text":""},{"location":"components/#clients","title":"Clients","text":"ror-admin <p>Webclient writen in angular.</p> ror-cli <p>cli-client writen in golang.</p>"},{"location":"components/#core","title":"Core","text":"ror-api <p>The main component of ror.</p> vault <p>Hashicorp vault, secretstorage and identity-manager for services in ROR</p> mongoDB <p>Database</p> ror-docs <p>127.0.0.1</p>"},{"location":"components/#microservices","title":"Microservices","text":"ror-ms-nhn <p>Microservice to do NHN spesific operations</p> ror-ms-auth <p>Microservice integrating dex</p> ror-ms-slack <p>Microservice integrating slack</p>"},{"location":"components/#distributed","title":"Distributed","text":"ror-operator <p>Low level cluster operator, bootstraping cluster integration and tooling.</p> ror-agent <p>In-cluster datacollector</p>"},{"location":"design/","title":"Design","text":""},{"location":"design/#central-component","title":"Central component","text":"<ul> <li>Multi datacenter<ul> <li>trd1-mgmt/mgmt-felles-0001</li> <li>osl1-mgmt/mgmt-felles-0001</li> </ul> </li> <li>Api<ul> <li>swagger</li> </ul> </li> <li> <p>Client</p> <ul> <li>ror-gui (Web frontend)</li> <li>ror-cli (CLI)</li> </ul> </li> <li> <p>Authentication OIDC</p> </li> <li>user (AD via dex)<ul> <li>api-tokens generated by ror</li> </ul> </li> <li> <p>service accounts </p> <ul> <li>cluster sa generated by ror, stored in vault</li> </ul> </li> <li> <p>Database/store</p> <ul> <li>MongoDB</li> <li>Vault</li> </ul> </li> <li> <p>Message/event system</p> <ul> <li>RabbitMQ</li> </ul> </li> </ul>"},{"location":"design/#distributed-component","title":"Distributed component","text":"<ul> <li>ror-agent</li> <li>ror-operator</li> </ul>"},{"location":"getting-started/","title":"Getting started with ROR development","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Linux distro or WSL2 for windows</li> <li>Docker runtime<ul> <li>Docker CE: https://docs.docker.com/engine/install/</li> <li>WSL2 tips: https://learn.microsoft.com/en-us/windows/wsl/systemd</li> </ul> </li> <li>Golang SDK (For debugging and changing) https://go.dev</li> <li>ROR API: https://github.com/NorskHelsenett/ror-api</li> <li>ROR Web: https://github.com/NorskHelsenett/ror-webapp</li> </ul>"},{"location":"getting-started/#optional","title":"Optional:","text":"<ul> <li>Docker Desktop (https://www.docker.com/products/docker-desktop/)</li> <li>Talosctl (https://www.talos.dev/v1.8/introduction/quickstart/)</li> <li>Kind (https://kind.sigs.k8s.io)</li> <li>K3d (https://k3d.io/stable/)</li> <li>Python for running documentation with mkdocs</li> <li>RO Agent: https://github.com/NorskHelsenett/ror-agent</li> </ul>"},{"location":"getting-started/#clone","title":"Clone","text":"<ol> <li>Create a folder on you computer where you want to put the code</li> <li>Clone the repository</li> </ol> <pre><code>git clone git@github.com:NorskHelsenett/ror.git\n</code></pre> <pre><code>git clone https://github.com/NorskHelsenett/ror.git\n</code></pre>"},{"location":"getting-started/#hardware-requirements","title":"Hardware requirements:","text":"Recommendations CPU Memory Minimum 2 16GB Recommended 4 32GB"},{"location":"getting-started/#install-docker","title":"Install docker","text":""},{"location":"getting-started/#linux","title":"Linux","text":"<p>Installation steps for Linux: https://docs.docker.com/engine/install Recommended post-installation steps: https://docs.docker.com/engine/install/linux-postinstall/</p>"},{"location":"getting-started/#fedora","title":"Fedora","text":"Fedora  ### Installations:  <pre><code>sudo dnf -y install dnf-plugins-core\nsudo dnf-3 config-manager --add-repo https://download.docker.com/linux/fedora/docker-ce.repo\n</code></pre>  :warning: if you receive errors like this, you might have an old Docker installation already installed:  <pre><code>- package docker-ce-3:27.3.1-1.fc40.x86_64 from docker-ce-stable conflicts with docker provided by moby-engine-24.0.5-4.fc40.x86_64 from fedora\n- package moby-engine-24.0.5-4.fc40.x86_64 from fedora conflicts with docker-ce provided by docker-ce-3:27.3.1-1.fc40.x86_64 from docker-ce-stable\n</code></pre>  #### Install the Docker Engine  <pre><code>sudo dnf install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre>  #### Start the Docker engine  <pre><code>sudo systemctl enable --now docker\n</code></pre>  #### (Optional) Install Docker auto-complete  https://docs.docker.com/engine/cli/completion/  #### (Optional) Test the docker installation  <pre><code>sudo docker run hello-world\n</code></pre>  #### Manage Dockker as a non-root  Doc reference: https://docs.docker.com/engine/install/linux-postinstall/  #### Create the docker group.  <pre><code>sudo groupadd docker\n</code></pre>  #### Add your user to the docker group.  <pre><code>sudo usermod -aG docker $USER\n</code></pre>  Log out and log back in so that your group membership is re-evaluated. :warning: If you're running Linux in a virtual machine, it may be necessary to restart the virtual machine for changes to take effect.  #### Verify  <pre><code>docker run hello-world\n</code></pre>"},{"location":"getting-started/#windows","title":"Windows","text":"<p>https://learn.microsoft.com/en-us/windows/wsl/systemd</p> <p>TODO</p>"},{"location":"getting-started/#starting-ror","title":"Starting ROR","text":""},{"location":"getting-started/#run-with-docker","title":"Run with docker","text":"<p>Note Specific environment variables need to be set up for ROR to run, see Environment Variables</p> <p>To start the ROR infrastructure you can run:</p> <pre><code>./r.sh\n</code></pre> <p>Which will start the Core infrastructure</p> <p>To include any optional services you can add them as arguments as shown:</p> <pre><code>./r.sh jaeger opentelemetry-collector\n</code></pre> <p>When the containers start you'll note that the following services will keep crashing, This is intended as they're dependent on the API service which has yet to be started:</p> <ul> <li>dex</li> <li>ms-auth</li> <li>ms-talos</li> <li>ms-kind</li> </ul>"},{"location":"getting-started/#ror-api","title":"ROR API","text":"<p>For ROR to work you require minimum the API, which can be found here: https://github.com/NorskHelsenett/ror-api</p>"},{"location":"getting-started/#visual-studio-code","title":"Visual Studio Code","text":"<ol> <li>Open the repository in VSCode</li> <li>Go to Debugging</li> <li>On \"Run and debug\" select \"Debug ROR-Api\" or \"Debug ROR-Api tests\"</li> </ol>"},{"location":"getting-started/#terminal","title":"Terminal","text":"<p>TODO</p>"},{"location":"getting-started/#ror-web","title":"ROR WEB","text":"<p>Clone the ror-webapp repository</p> <pre><code>git clone https://github.com/NorskHelsenett/ror-webapp\n</code></pre> <p>Start the core services as mentioned Here</p> <p>Start the API as mentioned Here</p> <p>Start the webapp as mentioned Here</p>"},{"location":"getting-started/#vscode","title":"VSCode","text":"<p>TODO</p>"},{"location":"getting-started/#terminal_1","title":"Terminal","text":"<p>TODO</p>"},{"location":"getting-started/#environment-variables","title":"Environment Variables","text":"<ul> <li>&lt;repo root&gt;/<code>.env</code> has the default settings for docker compose</li> <li>Env variables used during development are set in <code>hacks/docker-compose/</code></li> <li>Env variables used in cluster are set with charts in <code>charts/</code></li> </ul>"},{"location":"getting-started/#login-to-ror-web","title":"Login to ROR-web","text":"<p>Open your favorite browser, and go to http://localhost:11000 Log in with any of these accounts:</p> Title Username Password super admin <code>superadmin@ror.dev</code> <code>S3cret!</code> read only admin <code>readadmin@ror.dev</code> <code>S3cret!</code> developer 1 <code>dev1@ror.dev</code> <code>S3cret!</code> developer 2 <code>dev2@ror.dev</code> <code>S3cret!</code>"},{"location":"getting-started/#swagger","title":"Swagger","text":"<p>To see swagger for ROR Api, go to http://localhost:10000/swagger/index.html</p>"},{"location":"getting-started/#core-infrastructure","title":"Core infrastructure","text":"Service What Url ReadMe link Comment DEX Authentication www: http://localhost:5556, grpc api: http://localhost:5557 dex doc docker hub Reachable from inside and outside of docker Openldap Mocking users http://localhost:389 MongoDB Document database mongodb://localhost:27017 Mongo-Express Gui for document base http://localhost:8081 RabbitMQ Message bus GUI: http://localhost:15672, amqp port: localhost:5672 Vault Secrets handling GUI: http://localhost:8200 Valkey Cache GUI: http://localhost:6379"},{"location":"getting-started/#default-users","title":"Default users","text":"Service Username Password MongoDB <code>someone</code> <code>S3cret!</code> Mongo-Express <code>test</code> <code>S3cr3t</code> RabbitMQ <code>admin</code> <code>S3cret!</code>"},{"location":"getting-started/#optional-services","title":"Optional services","text":"Service What Url ReadMe link Comment jaeger opentelemetry-collector"},{"location":"getting-started/#ror-services","title":"ROR services","text":"Service What Url Port ReadMe link Comment ROR-Api Api http://localhost:10000 8080 ror-api ROR-WebApp Web http://localhost:11000 8090 ror-webapp ROR-Agent K8s Agent http://localhost:8100 8100 ror-agent Not run by docker-compose"},{"location":"getting-started/#known-issues","title":"Known issues","text":"<p>See Known-issues</p>"},{"location":"getting-started/#documentation","title":"Documentation","text":"<p>We pull documentation from code using some go package. Thus all functions should be annotated with a comment describing its use and any caveats. We keep system documentation in <code>cmd/docs/</code>, some files are copied in from .md files located in other parts of the repo using the <code>cmd/docs/collectdocs.sh</code> script. If you see any documentation that is out of date or wrong, please update it.</p>"},{"location":"known-issues/","title":"Systems","text":""},{"location":"known-issues/#mongodb","title":"MongoDB","text":"Error message cause potential solution <code>(RoleNotFound) Could not find role: roleRorApi@nhn-ror</code> mongo-init.js did not run stop r.sh and run <code>docker compose down &amp;&amp; docker system prune -a &amp;&amp; r.sh</code>"},{"location":"design/","title":"Design","text":""},{"location":"design/#web","title":"web","text":"<p>React-Framework</p>"},{"location":"design/react-framework/","title":"Architecture Decision Record: React framework for ROR Web GUI","text":""},{"location":"design/react-framework/#summary","title":"Summary","text":""},{"location":"design/react-framework/#issue","title":"Issue","text":"<p>We want to use a React framework to create our web application:   * We want to use React because it is easier to find people who know the framework   * We want to use a meta-framework that enables to do more heavy-lifting with simple configuration or conventions</p>"},{"location":"design/react-framework/#decision","title":"Decision","text":"<p>Decided on React Router v7. Decision made by @patrickedqvist, @havardelnan and @rogerwesterbo.</p>"},{"location":"design/react-framework/#status","title":"Status","text":"<p>Decided on React Router v7. If we are hindered by our choice the backup choice is Next.js.</p>"},{"location":"design/react-framework/#details","title":"Details","text":"<p>Two choices needed to be made. One is which framework to choose and the other choice which meta-framework should be used. The first choice has already been decided to be React due it's much higher usage <sup>1</sup>. It will simply be easier to acquire talent for a framework many people know. That leaves choosing a meta-framework or some type of tooling the meet our needs listed below.</p>"},{"location":"design/react-framework/#needs","title":"Needs","text":"<ul> <li>Support for running on node but preferably either on Bun or Deno</li> <li>Server-Side Rendering (SSR) out-of-the-box or with minimal configuration</li> <li>Routing</li> <li>Code-splitting capabilities</li> <li>Support for typescript</li> </ul>"},{"location":"design/react-framework/#nice-to-haves","title":"Nice to haves","text":"<ul> <li>Configurable cache-mechanics</li> <li>Serverless support (not sure how to utilities it properly, discuss.)</li> <li>Support for telemetry</li> </ul>"},{"location":"design/react-framework/#not-of-particular-interest","title":"Not of particular interest","text":"<ul> <li>Small client-side JS bundle size</li> <li>Can be dependent on JS to exist on the client machine</li> </ul>"},{"location":"design/react-framework/#meta-frameworks","title":"Meta frameworks","text":"<p>These are some known meta frameworks and toolings that support React that we will compare to our needs and wishes. We also compare some features to highlight how the different frameworks has solved them, such as how data-fetching is done.</p> <ol> <li>Next.js</li> <li>Astro</li> <li>React Router v7</li> </ol> <p>Remix is not considered as React Router v7 has replaced it (https://remix.run/blog/incremental-path-to-react-19). Vite with SSR is not considered since it is a low-level API for framework developers, but React Router v7 is built on this technology. Rakkas.js is another framework that was on the radar but it is not production-ready at this moment.</p> Feature Next.js Astro React Router v7 Supports Node.js Yes Yes Yes Supports Bun and/or Deno runtime Yes Yes Unknown Server-side rendering Yes Yes Yes <sup>3</sup> Routing File-based File-based Config-based Code-Splitting By route Granular (Island-Architecture) By route Configurable cache-mechanics Yes <sup>2</sup> No Yes <sup>4</sup> Methods for data-fetching Standard async/await in with React Server Components Standard async/await in .astro files clientLoader, loader, clientAction, action POST request handling Yes No Yes Middleware Yes Yes Yes Telemetry Yes No No Support for Typescript Yes Yes Yes"},{"location":"design/react-framework/#framework-differences","title":"Framework differences","text":"<p>While all these frameworks has a similar set of features there are architectural difference, they might have different levels of complexity for good and bad. In this section I try to highlight how the same set of features are solved differently.</p>"},{"location":"design/react-framework/#server-side-rendering-ssr-and-data-fetching","title":"Server-side rendering (SSR) and data-fetching","text":""},{"location":"design/react-framework/#nextjs","title":"Next.js","text":"<p>Next.js uses React Server Components per default. It enables the use of async and await inside if your component without any extra feature. You can also opt-out and use client-side data fetching for the places you want.</p> <p>Example <pre><code>import db from './database';\n\nasync function Note({id}) {\n    // NOTE: loads *during* render.\n    const note = await db.notes.get(id);\n    return (\n        &lt;div&gt;\n            &lt;Author id={note.authorId} /&gt;\n            &lt;p&gt;{note}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n}\n\nasync function Author({id}) {\n    // NOTE: loads *after* Note,\n    // but is fast if data is co-located.\n    const author = await db.authors.get(id);\n    return &lt;span&gt;By: {author.name}&lt;/span&gt;;\n}\n</code></pre></p>"},{"location":"design/react-framework/#astro","title":"Astro","text":"<p>The framework for content-driven websites. Astro has the possibility for using SSR but its speciality is generating static content. It follows an island-architecture approach where you create the main content as static but can create \"islands\" or \"regions\" where you can use one of the major client-side libraries (react, vue, svelte etc) to render an isolated interactive experience.</p> <p>Islands architecture works by rendering the majority of your page to fast, static HTML with smaller \u201cislands\u201d of JavaScript added when interactivity or personalization is needed on the page (an image carousel, for example). <sup>6</sup></p> <p>SSR is available but needs a runtime adapter to act as a server. Currently there are adapters for the popular JAM-stack hosting partners such as vercel and netlify. There is also a node adapter.</p> <p>Example <pre><code>---\nexport const prerender = false; // Not needed in configured 'server' mode\n\nimport { getProduct } from '../api';\n\nconst product = await getProduct(Astro.params.id);\n\n// No product found\nif (!product) {\n    return new Response(null, {\n        status: 404,\n        statusText: 'Not found'\n    });\n}\n\n// The product is no longer available\nif (!product.isAvailable) {\n    return Astro.redirect(\"/products\", 301);\n}\n\n---\n\n&lt;html&gt;\n\n&lt;!-- Page here... --&gt;\n\n&lt;/html&gt;\n</code></pre></p>"},{"location":"design/react-framework/#react-router-v7","title":"React Router v7","text":"<p>Version 7 of React Router is the next iteration of Remix. Remix was the best alternative to Next.js offering much of the same features. React Router uses some different namespaced methods for doing server-side fetching and rendering. In the example below it uses the function \"loader\" to fetch the data on the server. There are then functions for doing posting (usually used together with a form) and both fetching and posting on the client side.</p> <p>Example <pre><code>// route(\"products/:pid\", \"./product.tsx\");\nimport type { Route } from \"./+types/product\";\nimport { fakeDb } from \"../db\";\n\nexport async function loader({ params }: Route.LoaderArgs) {\n  const product = await fakeDb.getProduct(params.pid);\n  return product;\n}\n\nexport default function Product({\n  loaderData,\n}: Route.ComponentProps) {\n  const { name, description } = loaderData;\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;{name}&lt;/h1&gt;\n      &lt;p&gt;{description}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre></p> <p>The other big difference from the other frameworks is that uses a configuration for the routing rather than a file-based approach, although there is a possibility to implement file-based routing as well or even mix the two.</p> <p>Example <pre><code>import {\n  type RouteConfig,\n  route,\n  index,\n  layout,\n  prefix,\n} from \"@react-router/dev/routes\";\n\nexport default [\n  index(\"./home.tsx\"),\n  route(\"about\", \"./about.tsx\"),\n\n  layout(\"./auth/layout.tsx\", [\n    route(\"login\", \"./auth/login.tsx\"),\n    route(\"register\", \"./auth/register.tsx\"),\n  ]),\n\n  ...prefix(\"concerts\", [\n    index(\"./concerts/home.tsx\"),\n    route(\":city\", \"./concerts/city.tsx\"),\n    route(\"trending\", \"./concerts/trending.tsx\"),\n  ]),\n] satisfies RouteConfig;\n</code></pre></p>"},{"location":"design/react-framework/#ror-considerations","title":"ROR considerations","text":"<p>Since Astro is primarily meant for content-driven websites I think it's safe to assume that what we want to build diverge from their intention and ambition. We are looking for a framework that best fits building a data-heavy dashboard application. So I will simply write my pros and cons for Next.js and React Router v7.</p>"},{"location":"design/react-framework/#nextjs-pros","title":"Next.js Pros","text":"<ul> <li>Leans heavy on React v19 API and the two frameworks are constantly in dialog pushing React forward. If you learn and keep updated on React there are less boilerplate to think about for Next.js</li> <li>The most popular option - easy to find compatible libraries and people who have experience with it.</li> <li>Mature framework means flexibility and extendability without offering stability. Next.js offers many different features that are battle-proven.</li> </ul>"},{"location":"design/react-framework/#nextjs-cons","title":"Next.js Cons","text":"<ul> <li>Opiniated, it for instance builds on extending certain built-in standards. There for there are somethings that are Next.js specific that there are minimal documentation on.</li> <li>Vendor lock-in. Vercel is the company behind Next.js which mainly earns money from their hosting solution. Next.js and Vercels hosting solution is tightly coupled meaning that other alternatives does make full use out of the capabilities.</li> </ul>"},{"location":"design/react-framework/#react-router-pros","title":"React Router Pros","text":"<ul> <li>Very flexible routing could allow for an easier file-organization</li> <li>Familiarity - many people who have worked with React Single-Page-Applications have used React Router v6 or older versions and therefore there might be less of a hurdle to work with the framework.</li> <li>React Router uses the native Request and Response API making it easier for everyone to rely on MDN for documentation.</li> <li>Uses Vite under the hood which means it can use other peoples work to grow or for us to modify certain behaviour.</li> </ul>"},{"location":"design/react-framework/#react-router-cons","title":"React Router Cons","text":"<ul> <li>Excessive complexity, one of the pain points for many developers when it comes to meta-frameworks. React Router uses some of their own functionality for data-fetching, inherited from Remix. Since React 19 there is the question if these are really necessary or if the framework should solely rely on what is possible with for instance server actions and functions.</li> <li>React-Router in its current state does not extend much beyond routing and data-fetching. Meaning certain features can be harder to implement since it means configuring or extending Vite.</li> </ul> <ol> <li> <p>Source https://share.stateofjs.com/share/prerendered?localeId=en-US&amp;surveyId=state_of_js&amp;editionId=js2024&amp;blockId=front_end_frameworks_ratios&amp;params=&amp;sectionId=libraries&amp;subSectionId=front_end_frameworks ![[Front End Frameworks Ratios.png]]\u00a0\u21a9</p> </li> <li> <p>https://nextjs.org/docs/app/building-your-application/caching \u21a9</p> </li> <li> <p>They say it is supported but \"Server side rendering requires a deployment that supports it.\" without any further explanation. https://reactrouter.com/start/framework/rendering. Probably means you have setup your own server without guidance from the framework.\u00a0\u21a9</p> </li> <li> <p>By using custom Cache-Control headers on each route, note that it is not granular for different type of requests.\u00a0\u21a9</p> </li> <li> <p>SolidStart is built on top of https://nitro.build/ which has granular cache control.\u00a0\u21a9</p> </li> <li> <p>https://docs.astro.build/en/concepts/islands/ \u21a9</p> </li> </ol>"},{"location":"generator/getting-started/","title":"Getting started with creating a ROR resource definition","text":""},{"location":"generator/getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Good knowledge about the resource you're planning to implement</li> <li>Golang SDK: https://go.dev</li> </ul>"},{"location":"generator/getting-started/#optional","title":"Optional","text":"<ul> <li>A clear picture of what you want to implement and how go generalize it</li> </ul>"},{"location":"generator/getting-started/#general-information","title":"General information","text":"<p>When creating a new resource, editing, or deleting an existing resource for ROR the generator MUST be ran, this is required for amongst other things to update the TypeScript types.</p>"},{"location":"generator/getting-started/#getting-started","title":"Getting started","text":""},{"location":"generator/getting-started/#cloning-the-repository","title":"Cloning the repository","text":"<ol> <li>Create a folder for where you want to store the code.</li> <li>Clone the repository into it.</li> </ol> <pre><code>git clone git@github.com:NorskHelsenett/ror.git\n</code></pre> <pre><code>git clone https://github.com/NorskHelsenett/ror.git\n</code></pre> <p>For more information on this part see: https://norskhelsenett.github.io/ror/getting-started/</p>"},{"location":"generator/getting-started/#creating-the-base-resource-files","title":"Creating the base resource files","text":""},{"location":"generator/getting-started/#create-the-resource-definition","title":"Create the resource definition","text":"<ol> <li>Creating it at:</li> </ol> <pre><code>ror/pkg/rorresources/rortypes\n</code></pre> <p>with the format:</p> <pre><code>resourcedef_&lt;resourceName&gt;.go\n</code></pre> <ol> <li>When creating this file the following rule must be followed:<ul> <li>The package name is <code>rortypes</code></li> <li>The structs all begin with <code>Resource</code> resulting your type to be <code>Resource&lt;YourResourceName&gt;</code></li> <li>Your main struct should contain a <code>Spec</code> and a <code>Status</code> field</li> <li>The <code>Spec</code> is the desired state, while <code>Status</code> is observed state, more about that further down.</li> </ul> </li> </ol> <p>An example of a resourcedef:</p> <pre><code>package rortypes\n\ntype ResourceVirtualMachine struct {\n        Id     string                       `json:\"id\"`\n        Name   string                       `json:\"name\"`\n        Spec   ResourceVirtualMachineSpec   `json:\"spec\"`\n        Status ResourceVirtualMachineStatus `json:\"status\"`\n}\n\ntype ResourceVirtualMachineSpec struct {\n        Cpu             ResourceVirtualMachineCpuSpec             `json:\"cpu\"`\n        Tags            []ResourceVirtualMachineTagSpec           `json:\"tags\"`\n        Disks           []ResourceVirtualMachineDiskSpec          `json:\"disks\"`\n        Memory          ResourceVirtualMachineMemorySpec          `json:\"memory\"`\n        Networks        []ResourceVirtualMachineNetworkSpec       `json:\"networks\"`\n        OperatingSystem ResourceVirtualMachineOperatingSystemSpec `json:\"operatingSystem\"`\n}\n\ntype ResourceVirtualMachineStatus struct {\n        Cpu             ResourceVirtualMachineCpuStatus             `json:\"cpu\"`\n        Disks           []ResourceVirtualMachineDiskStatus          `json:\"disks\"`\n        Memory          ResourceVirtualMachineMemoryStatus          `json:\"memory\"`\n        Networks        []ResourceVirtualMachineNetworkStatus       `json:\"networks\"`\n        OperatingSystem ResourceVirtualMachineOperatingSystemStatus `json:\"operatingSystem\"`\n}\n.\n.\n.\n</code></pre>"},{"location":"generator/getting-started/#spec","title":"Spec","text":"<p>Spec will be what we desire the configuration to be for when we wish to change something, like cpu, disk, or memory for the example above. Any parameter within here it is expected we're allowed to change if change from ROR is implmeneted.</p> <p>If the resource is read-only Spec is necessary to implement.</p>"},{"location":"generator/getting-started/#status","title":"Status","text":"<p>Status will be what we observe about this resource, like ids, the current cpu, disk, or memory for the example above.</p>"},{"location":"generator/getting-started/#create-the-resource_input_filter-definition","title":"Create the resource_input_filter definition","text":"<p>The resource_input_filter runs on import on that type, it can be used to censor, anonymize, remove, or change data before import.</p> <p>While it has to be defined on every type, generally we create it and return nil for no action.</p> <ol> <li>Create it at:</li> </ol> <pre><code>ror/pkg/rorresources/rortypes\n</code></pre> <p>with the format:</p> <pre><code>resouce_input_filter&lt;resourceName&gt;.go\n</code></pre> <ol> <li>Which should contain something to this example with  swapped out with your core struct: <pre><code>package rortypes\n\n// (r *&lt;ResourceName&gt;) ApplyInputFilter Applies the input filter to the resource\nfunc (r *&lt;ResourceName&gt;) ApplyInputFilter(cr *CommonResource) error {\n        return nil\n}\n</code></pre>"},{"location":"generator/getting-started/#ror-definitions","title":"ROR definitions","text":"<ol> <li>Go to: <pre><code>ror/pkg/rorresources/rordefs\n</code></pre></li> <li>And edit defs.go</li> <li> <p>On the top const definition, add your new agent in the format: <pre><code>ApiResoureType&lt;Name&gt; ApiReesourceType = \"&lt;AgentName&gt;\"\n</code></pre></p> </li> <li> <p>And at the near bottom at at to the Resroucedefs slice: <pre><code>{\n        TypeMeta: metav1.TypeMeta{\n                Kind:       \"&lt;Name\",\n                APIVersion: \"&lt;Version of your choice&gt;\",\n        },\n        Plural:     \"&lt;Plural of name&gt;\",\n        Namespaced: false,\n        Types:      []ApiResourceType{&lt;Type&gt;},\n},\n</code></pre></p> </li> </ol>"},{"location":"generator/getting-started/#running-the-generator","title":"Running the generator","text":"<ol> <li>Go to the root folder of ROR</li> <li>Run the following command:</li> </ol> <pre><code>go run cmd/generator/main.go\n</code></pre> <ol> <li>And you're done, commit to the branch and make a pull/merge request.</li> </ol>"},{"location":"generator/getting-started/#afterwards","title":"Afterwards","text":"<ul> <li>To import data to this (newly) created ROR resource, you need to implement the ROR client, which you can read more about here: ror/docs/rorclient/getting-started.md</li> </ul>"},{"location":"mongodb/","title":"mongoDB","text":""},{"location":"ror-admin/","title":"ror-admin","text":""},{"location":"ror-agent/","title":"ror-agent","text":""},{"location":"ror-api/","title":"NHN-ROR-API","text":"<p>Webapi made with Golang and Gin webapi framework</p>"},{"location":"ror-api/#prerequisites","title":"Prerequisites","text":"<ul> <li>Golang 1.20.x https://go.dev</li> </ul>"},{"location":"ror-api/#get-started","title":"Get started","text":"<p>Bash commands is from <code>&lt;repo root&gt;/src/backend/ror-api/</code></p> <p>Download dependencies:</p> <pre><code>go get ./...\n</code></pre> <p>Start webapi</p> <pre><code>go run main.go\n</code></pre> <p>Or Start the <code>Debug ROR-Api</code> debugger config from VS Code</p>"},{"location":"ror-api/#generate-swagger-docs","title":"Generate swagger docs:","text":"<p>Foreach endpoint function, you must add comments for it to show in generated openapi spec</p> <p>ex:</p> <pre><code>// @Summary     Create cluster\n// @Schemes\n// @Description Create a cluster\n// @Tags        cluster\n// @Accept      application/json\n// @Produce     application/json\n// @Success     200 {object} responses.ClusterResponse\n// @Failure     403  {string}  Forbidden\n// @Failure     401  {string}  Unauthorized\n// @Failure     500  {string}  Failure message\n// @Router      /v1/cluster [post]\n// @Security    ApiKey || AccessToken\n// @tokenUrl    https://auth.sky.nhn.no/dex/token\n// @scope.write Grants write access\n// @scope.admin Grants read and write access to administrative information\nfunc Create() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        ...\n    }\n}\n</code></pre> <p>Examples of annotations</p> <p>To generate new swagger you need to install a cmd called <code>swag</code> (https://github.com/swaggo/swag):</p> <pre><code>go install github.com/swaggo/swag/cmd/swag@latest\n</code></pre> <p>(and remember to set <code>&lt;userprofile&gt;\\go\\bin</code> in PATH to terminal)</p> <p>And run this command from <code>ror-api</code> root:</p> <pre><code> swag init -g cmd/api/main.go --parseDependency --output cmd/api/docs\n</code></pre> <p>the folder <code>docs</code> and <code>docs\\swagger.json</code> and <code>docs\\swagger.yaml</code> is updated/created</p>"},{"location":"ror-api/aclv2/","title":"ACLv2","text":""},{"location":"ror-api/aclv2/#scopesubject","title":"Scope/subject","text":"<p>Acl v2 implements an accessmodel in two layers, scope og subject.</p>"},{"location":"ror-api/aclv2/#scope","title":"Scope","text":"<p>Scope represent the exten of the right. eg. if you want to grant access to a cluster the scope is cluster.</p> <p>There is a global scope called ror that aplies to the whole system</p> <p>All scopes are represented by the enum type Acl2Scope .</p>"},{"location":"ror-api/aclv2/#subject","title":"Subject","text":"<p>Subject represent id of the resource the access applies to. Eg. if the scope is cluster the subject is a clusterid.</p> <p>If the scope is ror the subject is a group of subject eg cluster granting access to all clusters. The largest spanning subject is Acl2RorSubjectGlobal</p> <p>Valid subjects under the scope ror is defined in the const Acl2RorSubject</p> <p>Scopes are represented by the type Acl2Subject that represents a string.</p>"},{"location":"ror-api/aclv2/#validation","title":"Validation","text":"<p>Scopes can be validated with the method (s Acl2Scope) IsValid() bool</p> <p>Subjects can be validated against its coresponding scope with the method *(s Acl2Subject) HasValidScope(scope Acl2Scope) bool</p>"},{"location":"ror-api/aclv2/#query","title":"Query","text":"<p>The query to the acl v2 engine should be represented by the type AclV2QueryAccessScopeSubject</p> <p>It must be created with the factory <code>NewAclV2QueryAccessScopeSubject(scope any, subject any) AclV2QueryAccessScopeSubject</code> which implements type casting and validation of the query.</p>"},{"location":"ror-api/aclv2/#access","title":"Access","text":"<p>Access is defined by the type  AclV2ListItemAccess as five boolean values representing Read, Create, Update, Delete, Owner.</p> <p>The returnes accessobject can be queried with the methods representing the level of acces we want to check eg:</p> <pre><code>accessQuery := aclmodels.NewAclV2QueryAccessScopeSubject(aclmodels.Acl2ScopeRor, aclmodels.Acl2RorSubjectGlobal)\naccessObject := aclservice.CheckAccessByContextAclQuery(ctx, accessQuery)\nif !accessObject.Read {\n    c.JSON(http.StatusForbidden, \"403: No access\")\n    return\n}\n</code></pre>"},{"location":"ror-api/api-endpoints/","title":"Api endpoints","text":"Method Endpoint acl POST /clusters/register NA GET /v1/m2m/ NA POST /v1/m2m/token NA POST /v1/m2m/heartbeat v2 POST /v1/m2m/resources v2 GET /v1/m2m/resources/hashes v2 POST /v1/m2m/metrics v2 GET /v1/m2m/configuration/operator v2 GET /v1/m2m/configuration/:name v2 GET /v1/desired_versions v2 GET /v1/desired_versions/:key v2 POST /v1/desired_versions v2 PUT /v1/desired_versions/:key v2 DELETE /v1/desired_versions/:key v2 POST /v1/clusters/filter v2 POST /v1/clusters/filter/workspace/:workspaceName/filter v2 GET /v1/clusters/metadata v2 GET /v1/workspaces v2 GET /v1/workspaces/:workspaceName v2 PUT /v1/workspaces/:id v2 GET /v1/datacenters v2 GET /v1/datacenters/:datacenterName v2 POST /v1/datacenters v2 PUT /v1/datacenters/:datacenterId v2 GET /v1/cluster/:clusterid v2 GET /v1/cluster/:clusterid/exists v2 PATCH /v1/cluster/:clusterid/metadata v2 GET /v1/cluster/:clusterid/resources/policyreports v2 GET /v1/metrics v2 GET /v1/metrics/total v2 GET /v1/metrics/datacenters v2 GET /v1/metrics/datacenter/:datacenterName v2 POST /v1/metrics/workspaces/filter v2 POST /v1/metrics/workspaces/datacenter/:datacenterName/filter v2 GET /v1/metrics/workspace/:workspaceName v2 GET /v1/metrics/clusters v2 GET /v1/metrics/clusters/workspace/:workspaceName v2 GET /v1/metrics/cluster/:clusterId v2 GET /v1/metrics/custom/cluster/:property v2 GET /v1/prices v2 GET /v1/prices/provider/:providerName v2 GET /v1/prices/:priceId v2 POST /v1/prices v2 PUT /v1/prices/:priceId v2 DELETE /v1/prices/:priceId* v2 GET /v1/users/self v2 POST /v1/users/self/apikeys v2 POST /v1/users/self/apikeys/filter v2 DELETE /v1/users/self/apikeys/:id v2 GET /v1/acl* v2 GET /v1/acl/migrate v2 POST /v1/apikeys/filter v2 DELETE /v1/apikeys/:id v2 POST /v1/auditlogs/filter v2 GET /v1/auditlogs/:id v2 GET /v1/auditlogs/metadata v2 GET /v1/projects/:id v2 GET /v1/projects/:id/clusters v2 POST /v1/projects/filter v2 POST /v1/projects v2 PUT /v1/projects/:id v2 DELETE /v1/projects/:id v2 GET /v1/tasks v2 GET /v1/tasks/:id v2 POST /v1/tasks v2 PUT /v1/tasks/:id v2 DELETE /v1/tasks/:id v2 GET /v1/operatorconfigs v2 GET /v1/operatorconfigs/:id v2 POST /v1/operatorconfigs v2 PUT /v1/operatorconfigs/:id v2 DELETE /v1/operatorconfigs/:id v2"},{"location":"ror-api/config-management/","title":"Config management","text":""},{"location":"ror-api/config-management/#mergestrategi","title":"Mergestrategi","text":""},{"location":"ror-cli/","title":"ror-cli","text":""},{"location":"ror-cli/auth-flow/","title":"auth-flow","text":""},{"location":"ror-cli/auth-flow/#api-credentials","title":"api-credentials","text":""},{"location":"ror-cli/auth-flow/#k8s-credentials","title":"k8s-credentials","text":""},{"location":"ror-docs/","title":"ror-docs","text":"<p>ror-docs ern en mkdocs-material side som genereres automatisk ved push til <code>docs/**/*</code> og <code>mkdocs.yaml</code>. mkdocs.yaml inneholder config og mapping av filer under /docs.</p>"},{"location":"ror-docs/#mapping-av-filer","title":"Mapping av filer","text":"<p>under <code>map:</code> i <code>mkdocs.yaml</code>defineres mapping av filer, f\u00f8rste niv\u00e5 er headere, underniv\u00e5 er trestruktur i sidemenyen.</p> <p>eks: <pre><code>nav:\n  - ROR:\n    - index.md\n    - components.md\n    - design.md\n    - getting-started.md\n  - Clients:\n    - ror-admin:\n      - ror-admin/index.md\n    - ror-cli:\n      - ror-cli/index.md\n      - ror-cli/auth-flow.md\n</code></pre></p>"},{"location":"ror-docs/#kodenr-dokumentasjon","title":"Koden\u00e6r dokumentasjon","text":"<p>Hvis dokumentasjonen er lagt sammen med koden kan den automatisk integreres med ror-docs ved \u00e5 legg til en kopieringskommando i filen <code>/cmd/docs/collectdocs.sh</code>. Husk \u00e5 mappe filen i <code>mkdocs.yaml</code></p> <p>eks: <pre><code>#!/bin/bash\n\n#API\ncp cmd/api/ReadMe.md docs/ror-api/index.md\n</code></pre></p>"},{"location":"ror-ms-auth/","title":"ror-ms-auth","text":""},{"location":"ror-ms-nhn/","title":"ror-ms-nhn","text":""},{"location":"ror-ms-slack/","title":"ror-ms-slack","text":""},{"location":"ror-operator/","title":"ror-operator","text":""},{"location":"ror-operator/#installation-flowchart","title":"Installation flowchart","text":""},{"location":"rorclient/getting-started/","title":"Getting started with ROR Client","text":""},{"location":"rorclient/getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>A ROR resourcedef - To create this see docs/ror-generator-client/docs/generator/getting-started.md</li> </ul>"},{"location":"rorclient/getting-started/#optional","title":"Optional","text":"<ul> <li>TODO</li> </ul>"},{"location":"rorclient/getting-started/#getting-started","title":"Getting started","text":""},{"location":"rorclient/getting-started/#configuration-variables","title":"Configuration variables","text":"<p>First to implement it we need to add the rorclient to the project</p> <pre><code>go get \"github.com/NorskHelsenett/ror/pkg/clients/rorclient\"\n</code></pre> <p>And then add configuration variables for the following parameters:</p> <p><code>BaseUrl</code></p> <p>The Url of the ROR instance you're communicating with.</p> <p><code>AuthProvider</code></p> <p>The auth proivder from \"github.com/NorskHelsenett/ror/pkg/clients/rorclient/transports/resttransport/httpauthprovider\" which is either: httpauthprovider.NewNoAuthProvider() or an actual AuthProvider</p> <p>TODO</p> <p><code>Version</code></p> <p>The current version of the client, for example 0.0.1: <p><code>Role</code></p> <p>The name of the client, for example vpshereAgent</p>"},{"location":"rorclient/getting-started/#implementation","title":"Implementation","text":""},{"location":"rorclient/getting-started/#implementing-the-ror-client","title":"Implementing the ROR client","text":"Example <pre><code>package rorclient\n\nimport (\n    \"github.com/NorskHelsenett/ror/pkg/clients/rorclient\"\n    \"github.com/NorskHelsenett/ror/pkg/clients/rorclient/transports/resttransport\"\n    \"github.com/NorskHelsenett/ror/pkg/clients/rorclient/transports/resttransport/httpauthprovider\"\n    \"github.com/NorskHelsenett/ror/pkg/clients/rorclient/transports/resttransport/httpclient\"\n    \"github.com/NorskHelsenett/ror/pkg/config/rorversion\"\n)\n\ntype config struct {\n    RorUrl string\n    RorRole string\n    RorCommit string\n    RorVersion string\n}\n\n// Populates the Config with values from environmental variables or static values \nfunc NewConfig() *Config {\n...\n...\n...\n}\n\nvar config Config = NewConfig()\n\ntype UpdateError struct {\n    uuid    string\n    status  int\n    message string\n}\n\n// So we can add our own methods to the RorClient struct\ntype RorClient struct {\n    rorclient.RorClient\n}\n\n// Constructs \nfunc NewRorClient(config config.Config) *RorClient {\n    transport := resttransport.NewRorHttpTransport(&amp;httpclient.HttpTransportClientConfig{\n        BaseURL:      config.RorUrl,\n        AuthProvider: httpauthprovider.NewNoAuthprovider(),\n        Version:      rorversion.NewRorVersion(config.RorVersion, config.RorCommit),\n        Role:         config.RorRole,\n    })\n\n    rorClient := RorClient{\n        *rorclient.NewRorClient(transport),\n    }\n\n    return &amp;rorClient\n}\n</code></pre>"},{"location":"rorclient/getting-started/#converting-the-resource-to-the-ror-resource","title":"Converting the resource to the ROR resource","text":"Example <pre><code>package rorclient\n\n// Adds or updates the VMs in ROR\nfunc (r *RorClient) UpdateVms(ctx context.Context, vmResources []*rortypes.ResourceVirtualMachine) error {\n    set := rorresources.NewResourceSet()\n\n    names := []string{}\n    for _, vm := range vmResources {\n        names = append(names, vm.Name)\n        res := rorresources.NewRorResource(\"VirtualMachine\", \"general.ror.internal/v1alpha1\")\n\n        res.RorMeta.Ownerref = rorresourceowner.RorResourceOwnerReference{\n            Scope:   aclmodels.Acl2ScopeRor,\n            Subject: aclmodels.Acl2RorSubjectGlobal,\n        }\n\n        v5Uuid, err := virtualmachine.UuidV5FromCompositeId(vm.Id)\n        if err != nil {\n            return fmt.Errorf(\"could not get uuid from vm resource: %w\", err)\n        }\n\n        res.Metadata.UID = types.UID(v5Uuid.String())\n        res.RorMeta.Action = rortypes.K8sActionAdd\n        res.Metadata.Name = vm.Name\n        res.SetVirtualMachine(vm)\n        set.Add(res)\n    }\n\n    res, err := r.ResourceV2().Update(ctx, *set)\n}\n</code></pre>"},{"location":"rorclient/getting-started/#adding-or-updating-using-the-ror-client","title":"Adding or updating using the ROR client","text":"Example <pre><code>package rorclient\n\n// Adds or updates the VMs in ROR\nfunc (r *RorClient) UpdateVms(ctx context.Context, vmResources []*rortypes.ResourceVirtualMachine) error {\n        res, err := r.ResourceV2().Update(ctx, *set)\n    if err != nil {\n        return fmt.Errorf(\"could not update vm, ROR returned: %w\", err)\n    }\n\n    var errors UpdateErrors\n    for uuid, response := range *&amp;res.Results {\n        if response.Status &gt; 299 {\n            error := UpdateError{\n                uuid:    uuid,\n                status:  response.Status,\n                message: response.Message,\n            }\n\n            errors.Errors = append(errors.Errors, error)\n        }\n    }\n\n    if len(errors.Errors) != 0 {\n        return errors\n    }\n\n    return nil\n}\n\n// Deletes VMs\nfunc (r *RorClient) DeleteVms(ctx context.Context, uuids []string) error {\n    for _, uid := range uuids {\n        del, err := r.ResourceV2().Delete(ctx, uid)\n        slog.Info(\"deleted vm\", \"info\", del)\n        if err != nil {\n            return fmt.Errorf(\"could not delete vm, ROR returned %w\", err)\n        }\n    }\n    return nil\n}\n</code></pre>"},{"location":"rorclient/getting-started/#deleting-using-the-ror-client","title":"Deleting using the ROR client","text":"Example <pre><code>package rorclient\n\nfunc (r *RorClient) DeleteVms(ctx context.Context, uuids []string) error {\n    for _, uid := range uuids {\n        del, err := r.ResourceV2().Delete(ctx, uid)\n        slog.Info(\"deleted vm\", \"info\", del)\n        if err != nil {\n            return fmt.Errorf(\"could not delete vm, ROR returned %w\", err)\n        }\n    }\n    return nil\n}\n</code></pre>"},{"location":"vault/","title":"vault","text":""}]}